<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Idds__Idd (idds.Idds__Idd)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">idds</a> &#x00BB; Idds__Idd</nav><h1>Module <code>Idds__Idd</code></h1><p>Identity Suppressed Decision Diagrams (IDDs).</p><nav class="toc"><ul><li><a href="#types">Types</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#boolean-operations">Boolean operations</a></li><li><a href="#semantics">Semantics</a></li></ul></nav></header><section><header><h3 id="types"><a href="#types" class="anchor"></a>Types</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span class="keyword">private</span> <a href="../Idds/Dd/index.html#type-t">Idds.Dd.t</a></code></dt><dd><p>An IDD is just a DD with two additional structural constraints that ensure canonicity: two IDDs encode the same function iff they are the same IDD.</p></dd></dl><dl><dt class="spec type" id="type-manager"><a href="#type-manager" class="anchor"></a><code><span class="keyword">type</span> manager</code></dt></dl><dl><dt class="spec value" id="val-manager"><a href="#val-manager" class="anchor"></a><code><span class="keyword">val</span> manager : <span>?&#8288;bdd_mgr:<a href="../Idds/Bdd/index.html#type-manager">Idds.Bdd.manager</a></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-manager">manager</a></code></dt><dt class="spec value" id="val-get_bdd_manager"><a href="#val-get_bdd_manager" class="anchor"></a><code><span class="keyword">val</span> get_bdd_manager : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> <a href="../Idds/Bdd/index.html#type-manager">Idds.Bdd.manager</a></code></dt></dl></section><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-ident"><a href="#val-ident" class="anchor"></a><code><span class="keyword">val</span> ident : <a href="index.html#type-t">t</a></code></dt><dd><p>The identity relation.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dd><p>The empty relation.</p></dd></dl><dl><dt class="spec value" id="val-of_bdd"><a href="#val-of_bdd" class="anchor"></a><code><span class="keyword">val</span> of_bdd : <a href="../Idds/Bdd/index.html#type-t">Idds.Bdd.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>if <code>bdd</code> contains no output variables then Bdd.eval bdd ~env = Idd.(eval (of_bdd bdd) ~env); otherwise, behavior is undefined</p></dd></dl><dl><dt class="spec value" id="val-test"><a href="#val-test" class="anchor"></a><code><span class="keyword">val</span> test : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>For i &lt; n, eval (test i b) env n = env (Var.inp i) = b &amp;&amp; eval ident env n rel n (test i b) = { (x,x) | x \in B^n, x_i = b }</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>For i &lt; n, eval (set i b) env n = eval ident env' n, where env' x = if x = Var.inp i then b else env x rel n (set i b) = { (x,x<code>i:=b</code>) | x \in B^n }</p></dd></dl><dl><dt class="spec value" id="val-branch"><a href="#val-branch" class="anchor"></a><code><span class="keyword">val</span> branch : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> <a href="../Idds/Var/index.html#type-t">Idds.Var.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>branch mgr var hi lo</code> is the diagram that behaves like <code>hi</code> when <code>var = true</code>, and like <code>lo</code> when <code>var = false</code>.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> <span>(bool <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>apply mgr op t0 t1</code> is <code>t</code> such that <code>Bool.equal (op (eval t0 env n) (eval t1 env n)) (eval t env n)</code></p></dd></dl><dl><dt class="spec value" id="val-seq"><a href="#val-seq" class="anchor"></a><code><span class="keyword">val</span> seq : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sequential composition</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>(Relational) union</p></dd></dl><dl><dt class="spec value" id="val-star"><a href="#val-star" class="anchor"></a><code><span class="keyword">val</span> star : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>(Relational) transitive-reflexive closure</p></dd></dl></section><section><header><h3 id="boolean-operations"><a href="#boolean-operations" class="anchor"></a>Boolean operations</h3></header><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>O(1) structural equality.</p><p><b>PRECONDITION</b>: The result of <code>equal u v</code> is only defined when <code>u</code> and <code>v</code> were built using the same manager. Otherwise, the result is arbitrary.</p></dd></dl><dl><dt class="spec value" id="val-subseteq"><a href="#val-subseteq" class="anchor"></a><code><span class="keyword">val</span> subseteq : <a href="index.html#type-manager">manager</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>relational containment</p></dd></dl></section><section><header><h3 id="semantics"><a href="#semantics" class="anchor"></a>Semantics</h3></header><dl><dt class="spec value" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span class="keyword">val</span> eval : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(<a href="../Idds/Var/index.html#type-t">Idds.Var.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p><code>eval tree env n</code> evaluates idd <code>tree</code> in environment <code>env</code> where the variable indices are 0,...,<code>n-1</code></p></dd></dl></section></div></body></html>